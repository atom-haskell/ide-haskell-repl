"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const ide_haskell_repl_base_1 = require("./ide-haskell-repl-base");
const path = require("path");
class IdeHaskellReplBg extends ide_haskell_repl_base_1.IdeHaskellReplBase {
    constructor(consumer, state) {
        super(Promise.resolve(consumer), state, `bg:${state.uri}`);
    }
    showTypeAt(uri, inrange) {
        if (!this.types) {
            return undefined;
        }
        const typeRec = this.types.find((tr) => tr && tr.uri === uri && tr.span.containsRange(inrange));
        if (!typeRec) {
            return undefined;
        }
        const { span: range, type: text } = typeRec;
        const highlighter = 'hint.type.haskell';
        return { range, text: { text, highlighter } };
    }
    async destroy() {
        return super.destroy();
    }
    async update() {
    }
    async onLoad() {
        await super.onLoad();
        await this.getAllTypes();
    }
    async getAllTypes() {
        if (!this.ghci) {
            throw new Error('No GHCI instance!');
        }
        const { stdout } = await this.ghci.writeLines([':all-types']);
        this.types = [];
        for (const line of stdout) {
            const rx = /^(.*):\((\d+),(\d+)\)-\((\d+),(\d+)\):\s*(.*)$/;
            const match = line.match(rx);
            if (!match) {
                continue;
            }
            const m = match.slice(1);
            let uri = m[0];
            if (!path.isAbsolute(uri)) {
                if (this.cwd) {
                    uri = this.cwd.getFile(uri).getPath();
                }
                else {
                    const rd = await ide_haskell_repl_base_1.IdeHaskellReplBase.getRootDir(this.uri);
                    uri = rd.getFile(uri).getPath();
                }
            }
            const type = m[5];
            const [rowstart, colstart, rowend, colend] = m
                .slice(1)
                .map((i) => parseInt(i, 10) - 1);
            const span = atom_1.Range.fromObject([[rowstart, colstart], [rowend, colend]]);
            this.types.push({ uri, type, span });
        }
        return this.types;
    }
}
exports.IdeHaskellReplBg = IdeHaskellReplBg;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlLWhhc2tlbGwtcmVwbC1iZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pZGUtaGFza2VsbC1yZXBsLWJnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQTRCO0FBRTVCLG1FQUlnQztBQUNoQyw2QkFBNEI7QUFXNUIsc0JBQThCLFNBQVEsMENBQWtCO0lBRXRELFlBQVksUUFBcUIsRUFBRSxLQUFpQjtRQUNsRCxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQTtJQUM1RCxDQUFDO0lBRU0sVUFBVSxDQUFDLEdBQVcsRUFBRSxPQUFjO1FBQzNDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDaEIsTUFBTSxDQUFDLFNBQVMsQ0FBQTtRQUNsQixDQUFDO1FBQ0QsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQzdCLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQy9ELENBQUE7UUFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDYixNQUFNLENBQUMsU0FBUyxDQUFBO1FBQ2xCLENBQUM7UUFDRCxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFBO1FBQzNDLE1BQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFBO1FBQ3ZDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQTtJQUMvQyxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUN4QixDQUFDO0lBRU0sS0FBSyxDQUFDLE1BQU07SUFFbkIsQ0FBQztJQUVTLEtBQUssQ0FBQyxNQUFNO1FBQ3BCLE1BQU0sS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFBO1FBQ3BCLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFBO0lBQzFCLENBQUM7SUFFUyxLQUFLLENBQUMsV0FBVztRQUN6QixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO1FBQ3RDLENBQUM7UUFDRCxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7UUFDN0QsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUE7UUFDZixHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzFCLE1BQU0sRUFBRSxHQUFHLGdEQUFnRCxDQUFBO1lBQzNELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7WUFDNUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNYLFFBQVEsQ0FBQTtZQUNWLENBQUM7WUFDRCxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ3hCLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNkLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUNiLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtnQkFDdkMsQ0FBQztnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDTixNQUFNLEVBQUUsR0FBRyxNQUFNLDBDQUFrQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7b0JBQ3hELEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFBO2dCQUNqQyxDQUFDO1lBQ0gsQ0FBQztZQUNELE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNqQixNQUFNLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQztpQkFDM0MsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDUixHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7WUFDbEMsTUFBTSxJQUFJLEdBQUcsWUFBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUN2RSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQTtRQUN0QyxDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUE7SUFDbkIsQ0FBQztDQUNGO0FBakVELDRDQWlFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJhbmdlIH0gZnJvbSAnYXRvbSdcblxuaW1wb3J0IHtcbiAgSUNvbnRlbnRJdGVtLFxuICBJZGVIYXNrZWxsUmVwbEJhc2UsXG4gIElWaWV3U3RhdGUsXG59IGZyb20gJy4vaWRlLWhhc2tlbGwtcmVwbC1iYXNlJ1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IHsgVVBJQ29uc3VtZXIgfSBmcm9tICcuL3VwaUNvbnN1bWVyJ1xuXG5leHBvcnQgeyBJVmlld1N0YXRlLCBJQ29udGVudEl0ZW0gfVxuXG5leHBvcnQgaW50ZXJmYWNlIElUeXBlUmVjb3JkIHtcbiAgdXJpOiBzdHJpbmdcbiAgdHlwZTogc3RyaW5nXG4gIHNwYW46IFJhbmdlXG59XG5cbmV4cG9ydCBjbGFzcyBJZGVIYXNrZWxsUmVwbEJnIGV4dGVuZHMgSWRlSGFza2VsbFJlcGxCYXNlIHtcbiAgcHJpdmF0ZSB0eXBlcz86IElUeXBlUmVjb3JkW11cbiAgY29uc3RydWN0b3IoY29uc3VtZXI6IFVQSUNvbnN1bWVyLCBzdGF0ZTogSVZpZXdTdGF0ZSkge1xuICAgIHN1cGVyKFByb21pc2UucmVzb2x2ZShjb25zdW1lciksIHN0YXRlLCBgYmc6JHtzdGF0ZS51cml9YClcbiAgfVxuXG4gIHB1YmxpYyBzaG93VHlwZUF0KHVyaTogc3RyaW5nLCBpbnJhbmdlOiBSYW5nZSkge1xuICAgIGlmICghdGhpcy50eXBlcykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBjb25zdCB0eXBlUmVjID0gdGhpcy50eXBlcy5maW5kKFxuICAgICAgKHRyKSA9PiB0ciAmJiB0ci51cmkgPT09IHVyaSAmJiB0ci5zcGFuLmNvbnRhaW5zUmFuZ2UoaW5yYW5nZSksXG4gICAgKVxuICAgIGlmICghdHlwZVJlYykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBjb25zdCB7IHNwYW46IHJhbmdlLCB0eXBlOiB0ZXh0IH0gPSB0eXBlUmVjXG4gICAgY29uc3QgaGlnaGxpZ2h0ZXIgPSAnaGludC50eXBlLmhhc2tlbGwnXG4gICAgcmV0dXJuIHsgcmFuZ2UsIHRleHQ6IHsgdGV4dCwgaGlnaGxpZ2h0ZXIgfSB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdXBkYXRlKCkge1xuICAgIC8vIG5vb3BcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBvbkxvYWQoKSB7XG4gICAgYXdhaXQgc3VwZXIub25Mb2FkKClcbiAgICBhd2FpdCB0aGlzLmdldEFsbFR5cGVzKClcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBbGxUeXBlcygpOiBQcm9taXNlPElUeXBlUmVjb3JkW10+IHtcbiAgICBpZiAoIXRoaXMuZ2hjaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBHSENJIGluc3RhbmNlIScpXG4gICAgfVxuICAgIGNvbnN0IHsgc3Rkb3V0IH0gPSBhd2FpdCB0aGlzLmdoY2kud3JpdGVMaW5lcyhbJzphbGwtdHlwZXMnXSlcbiAgICB0aGlzLnR5cGVzID0gW11cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygc3Rkb3V0KSB7XG4gICAgICBjb25zdCByeCA9IC9eKC4qKTpcXCgoXFxkKyksKFxcZCspXFwpLVxcKChcXGQrKSwoXFxkKylcXCk6XFxzKiguKikkL1xuICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHJ4KVxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY29uc3QgbSA9IG1hdGNoLnNsaWNlKDEpXG4gICAgICBsZXQgdXJpID0gbVswXVxuICAgICAgaWYgKCFwYXRoLmlzQWJzb2x1dGUodXJpKSkge1xuICAgICAgICBpZiAodGhpcy5jd2QpIHtcbiAgICAgICAgICB1cmkgPSB0aGlzLmN3ZC5nZXRGaWxlKHVyaSkuZ2V0UGF0aCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmQgPSBhd2FpdCBJZGVIYXNrZWxsUmVwbEJhc2UuZ2V0Um9vdERpcih0aGlzLnVyaSlcbiAgICAgICAgICB1cmkgPSByZC5nZXRGaWxlKHVyaSkuZ2V0UGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBtWzVdXG4gICAgICBjb25zdCBbcm93c3RhcnQsIGNvbHN0YXJ0LCByb3dlbmQsIGNvbGVuZF0gPSBtXG4gICAgICAgIC5zbGljZSgxKVxuICAgICAgICAubWFwKChpKSA9PiBwYXJzZUludChpLCAxMCkgLSAxKVxuICAgICAgY29uc3Qgc3BhbiA9IFJhbmdlLmZyb21PYmplY3QoW1tyb3dzdGFydCwgY29sc3RhcnRdLCBbcm93ZW5kLCBjb2xlbmRdXSlcbiAgICAgIHRoaXMudHlwZXMucHVzaCh7IHVyaSwgdHlwZSwgc3BhbiB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy50eXBlc1xuICB9XG59XG4iXX0=