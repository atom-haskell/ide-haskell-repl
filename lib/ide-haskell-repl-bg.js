"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const ide_haskell_repl_base_1 = require("./ide-haskell-repl-base");
class IdeHaskellReplBg extends ide_haskell_repl_base_1.IdeHaskellReplBase {
    constructor(upiPromise, state) {
        super(upiPromise, state);
    }
    showTypeAt(uri, inrange) {
        if (!this.types) {
            return undefined;
        }
        const typeRec = this.types.find((tr) => tr && tr.uri === uri && tr.span.containsRange(inrange));
        if (!typeRec) {
            return undefined;
        }
        const { span: range, type: text } = typeRec;
        const highlighter = 'hint.type.haskell';
        return { range, text: { text, highlighter } };
    }
    async destroy() {
        return super.destroy();
    }
    async update() {
    }
    async onLoad() {
        await this.getAllTypes();
    }
    async onInitialLoad() {
        if (!this.ghci) {
            throw new Error('No GHCI instance!');
        }
        await this.ghci.writeLines([':set +c']);
        await this.ghciReload();
        return super.onInitialLoad();
    }
    async getAllTypes() {
        if (!this.ghci) {
            throw new Error('No GHCI instance!');
        }
        const { stdout } = await this.ghci.writeLines([':all-types']);
        this.types = [];
        for (const line of stdout) {
            const rx = /^(.*):\((\d+),(\d+)\)-\((\d+),(\d+)\):\s*(.*)$/;
            const match = line.match(rx);
            if (!match) {
                continue;
            }
            const m = match.slice(1);
            const uri = m[0];
            const type = m[5];
            const [rowstart, colstart, rowend, colend] = m.slice(1).map((i) => parseInt(i, 10) - 1);
            const span = atom_1.Range.fromObject([[rowstart, colstart], [rowend, colend]]);
            this.types.push({ uri, type, span });
        }
        return this.types;
    }
}
exports.IdeHaskellReplBg = IdeHaskellReplBg;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlLWhhc2tlbGwtcmVwbC1iZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pZGUtaGFza2VsbC1yZXBsLWJnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBRWE7QUFFYixtRUFJZ0M7QUFZaEMsc0JBQThCLFNBQVEsMENBQWtCO0lBRXRELFlBQWEsVUFBcUMsRUFBRSxLQUFpQjtRQUNuRSxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQzFCLENBQUM7SUFFTSxVQUFVLENBQUUsR0FBVyxFQUFFLE9BQXdCO1FBQ3RELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFBQyxNQUFNLENBQUMsU0FBUyxDQUFBO1FBQUMsQ0FBQztRQUNyQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUE7UUFDL0YsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQTtRQUFDLENBQUM7UUFDbEMsTUFBTSxFQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQyxHQUFHLE9BQU8sQ0FBQTtRQUN6QyxNQUFNLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQTtRQUN2QyxNQUFNLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFDLENBQUE7SUFDOUMsQ0FBQztJQUVNLEtBQUssQ0FBQyxPQUFPO1FBQ2xCLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUE7SUFDeEIsQ0FBQztJQUVNLEtBQUssQ0FBQyxNQUFNO0lBRW5CLENBQUM7SUFFUyxLQUFLLENBQUMsTUFBTTtRQUNwQixNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQTtJQUMxQixDQUFDO0lBRVMsS0FBSyxDQUFDLGFBQWE7UUFDM0IsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtRQUFDLENBQUM7UUFDeEQsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUE7UUFDdkMsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUE7UUFDdkIsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQTtJQUM5QixDQUFDO0lBRVMsS0FBSyxDQUFDLFdBQVc7UUFDekIsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtRQUFDLENBQUM7UUFDeEQsTUFBTSxFQUFDLE1BQU0sRUFBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFBO1FBQzNELElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFBO1FBQ2YsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQztZQUMxQixNQUFNLEVBQUUsR0FBRyxnREFBZ0QsQ0FBQTtZQUMzRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1lBQzVCLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDWCxRQUFRLENBQUE7WUFDVixDQUFDO1lBQ0QsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUN4QixNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDaEIsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ2pCLE1BQU0sQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtZQUN2RixNQUFNLElBQUksR0FBRyxZQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ3ZFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFBO1FBQ3BDLENBQUM7UUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQTtJQUNuQixDQUFDO0NBQ0Y7QUFyREQsNENBcURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgUmFuZ2UsXG59IGZyb20gJ2F0b20nXG5cbmltcG9ydCB7XG4gIElDb250ZW50SXRlbSxcbiAgSWRlSGFza2VsbFJlcGxCYXNlLFxuICBJVmlld1N0YXRlLFxufSBmcm9tICcuL2lkZS1oYXNrZWxsLXJlcGwtYmFzZSdcbmltcG9ydCAqIGFzIFVQSSBmcm9tICdhdG9tLWhhc2tlbGwtdXBpJ1xuaW1wb3J0ICogYXMgQXRvbVR5cGVzIGZyb20gJ2F0b20nXG5cbmV4cG9ydCB7SVZpZXdTdGF0ZSwgSUNvbnRlbnRJdGVtfVxuXG5leHBvcnQgaW50ZXJmYWNlIElUeXBlUmVjb3JkIHtcbiAgdXJpOiBzdHJpbmdcbiAgdHlwZTogc3RyaW5nXG4gIHNwYW46IFJhbmdlXG59XG5cbmV4cG9ydCBjbGFzcyBJZGVIYXNrZWxsUmVwbEJnIGV4dGVuZHMgSWRlSGFza2VsbFJlcGxCYXNlIHtcbiAgcHJpdmF0ZSB0eXBlcz86IElUeXBlUmVjb3JkW11cbiAgY29uc3RydWN0b3IgKHVwaVByb21pc2U6IFByb21pc2U8VVBJLklVUElJbnN0YW5jZT4sIHN0YXRlOiBJVmlld1N0YXRlKSB7XG4gICAgc3VwZXIodXBpUHJvbWlzZSwgc3RhdGUpXG4gIH1cblxuICBwdWJsaWMgc2hvd1R5cGVBdCAodXJpOiBzdHJpbmcsIGlucmFuZ2U6IEF0b21UeXBlcy5SYW5nZSkge1xuICAgIGlmICghdGhpcy50eXBlcykgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgICBjb25zdCB0eXBlUmVjID0gdGhpcy50eXBlcy5maW5kKCh0cikgPT4gdHIgJiYgdHIudXJpID09PSB1cmkgJiYgdHIuc3Bhbi5jb250YWluc1JhbmdlKGlucmFuZ2UpKVxuICAgIGlmICghdHlwZVJlYykgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgICBjb25zdCB7c3BhbjogcmFuZ2UsIHR5cGU6IHRleHR9ID0gdHlwZVJlY1xuICAgIGNvbnN0IGhpZ2hsaWdodGVyID0gJ2hpbnQudHlwZS5oYXNrZWxsJ1xuICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0OiB7IHRleHQsIGhpZ2hsaWdodGVyIH19XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVzdHJveSAoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHVwZGF0ZSAoKSB7XG4gICAgLy8gbm9vcFxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIG9uTG9hZCAoKSB7XG4gICAgYXdhaXQgdGhpcy5nZXRBbGxUeXBlcygpXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgb25Jbml0aWFsTG9hZCAoKSB7XG4gICAgaWYgKCF0aGlzLmdoY2kpIHsgdGhyb3cgbmV3IEVycm9yKCdObyBHSENJIGluc3RhbmNlIScpIH1cbiAgICBhd2FpdCB0aGlzLmdoY2kud3JpdGVMaW5lcyhbJzpzZXQgK2MnXSlcbiAgICBhd2FpdCB0aGlzLmdoY2lSZWxvYWQoKVxuICAgIHJldHVybiBzdXBlci5vbkluaXRpYWxMb2FkKClcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBbGxUeXBlcyAoKTogUHJvbWlzZTxJVHlwZVJlY29yZFtdPiB7XG4gICAgaWYgKCF0aGlzLmdoY2kpIHsgdGhyb3cgbmV3IEVycm9yKCdObyBHSENJIGluc3RhbmNlIScpIH1cbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHRoaXMuZ2hjaS53cml0ZUxpbmVzKFsnOmFsbC10eXBlcyddKVxuICAgIHRoaXMudHlwZXMgPSBbXVxuICAgIGZvciAoY29uc3QgbGluZSBvZiBzdGRvdXQpIHtcbiAgICAgIGNvbnN0IHJ4ID0gL14oLiopOlxcKChcXGQrKSwoXFxkKylcXCktXFwoKFxcZCspLChcXGQrKVxcKTpcXHMqKC4qKSQvXG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocngpXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBtID0gbWF0Y2guc2xpY2UoMSlcbiAgICAgIGNvbnN0IHVyaSA9IG1bMF1cbiAgICAgIGNvbnN0IHR5cGUgPSBtWzVdXG4gICAgICBjb25zdCBbcm93c3RhcnQsIGNvbHN0YXJ0LCByb3dlbmQsIGNvbGVuZF0gPSBtLnNsaWNlKDEpLm1hcCgoaSkgPT4gcGFyc2VJbnQoaSwgMTApIC0gMSlcbiAgICAgIGNvbnN0IHNwYW4gPSBSYW5nZS5mcm9tT2JqZWN0KFtbcm93c3RhcnQsIGNvbHN0YXJ0XSwgW3Jvd2VuZCwgY29sZW5kXV0pXG4gICAgICB0aGlzLnR5cGVzLnB1c2goe3VyaSwgdHlwZSwgc3Bhbn0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR5cGVzXG4gIH1cbn1cbiJdfQ==