"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const ide_haskell_repl_base_1 = require("./ide-haskell-repl-base");
class IdeHaskellReplBg extends ide_haskell_repl_base_1.IdeHaskellReplBase {
    constructor(upiPromise, state) {
        super(upiPromise, state);
    }
    showTypeAt(uri, inrange) {
        if (!this.types) {
            return undefined;
        }
        const typeRec = this.types.find((tr) => tr && tr.uri === uri && tr.span.containsRange(inrange));
        if (!typeRec) {
            return undefined;
        }
        const { span: range, type: text } = typeRec;
        const highlighter = 'hint.type.haskell';
        return { range, text: { text, highlighter } };
    }
    async destroy() {
        return super.destroy();
    }
    async update() {
    }
    async onLoad() {
        await this.getAllTypes();
    }
    async onInitialLoad() {
        if (!this.ghci) {
            throw new Error('No GHCI instance!');
        }
        await this.ghci.writeLines([':set +c']);
        await this.ghciReload();
        return super.onInitialLoad();
    }
    async getAllTypes() {
        if (!this.ghci) {
            throw new Error('No GHCI instance!');
        }
        const { stdout } = await this.ghci.writeLines([':all-types']);
        this.types = [];
        for (const line of stdout) {
            const rx = /^(.*):\((\d+),(\d+)\)-\((\d+),(\d+)\):\s*(.*)$/;
            const match = line.match(rx);
            if (!match) {
                continue;
            }
            const m = match.slice(1);
            const uri = m[0];
            const type = m[5];
            const [rowstart, colstart, rowend, colend] = m.slice(1).map((i) => parseInt(i, 10) - 1);
            const span = atom_1.Range.fromObject([[rowstart, colstart], [rowend, colend]]);
            this.types.push({ uri, type, span });
        }
        return this.types;
    }
}
exports.IdeHaskellReplBg = IdeHaskellReplBg;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlLWhhc2tlbGwtcmVwbC1iZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pZGUtaGFza2VsbC1yZXBsLWJnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBRWE7QUFFYixtRUFJZ0M7QUFXaEMsc0JBQThCLFNBQVEsMENBQWtCO0lBRXRELFlBQWEsVUFBcUMsRUFBRSxLQUFpQjtRQUNuRSxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFBO0lBQzFCLENBQUM7SUFFTSxVQUFVLENBQUUsR0FBVyxFQUFFLE9BQWM7UUFDNUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUE7UUFBQyxDQUFDO1FBQ3JDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQTtRQUMvRixFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFBQyxNQUFNLENBQUMsU0FBUyxDQUFBO1FBQUMsQ0FBQztRQUNsQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFBO1FBQzNDLE1BQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFBO1FBQ3ZDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQTtJQUMvQyxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUN4QixDQUFDO0lBRU0sS0FBSyxDQUFDLE1BQU07SUFFbkIsQ0FBQztJQUVTLEtBQUssQ0FBQyxNQUFNO1FBQ3BCLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFBO0lBQzFCLENBQUM7SUFFUyxLQUFLLENBQUMsYUFBYTtRQUMzQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO1FBQUMsQ0FBQztRQUN4RCxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQTtRQUN2QyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQTtRQUN2QixNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFBO0lBQzlCLENBQUM7SUFFUyxLQUFLLENBQUMsV0FBVztRQUN6QixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO1FBQUMsQ0FBQztRQUN4RCxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7UUFDN0QsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUE7UUFDZixHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzFCLE1BQU0sRUFBRSxHQUFHLGdEQUFnRCxDQUFBO1lBQzNELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7WUFDNUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNYLFFBQVEsQ0FBQTtZQUNWLENBQUM7WUFDRCxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ3hCLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNoQixNQUFNLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDakIsTUFBTSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO1lBQ3ZGLE1BQU0sSUFBSSxHQUFHLFlBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDdkUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7UUFDdEMsQ0FBQztRQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFBO0lBQ25CLENBQUM7Q0FDRjtBQXJERCw0Q0FxREMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBSYW5nZSxcbn0gZnJvbSAnYXRvbSdcblxuaW1wb3J0IHtcbiAgSUNvbnRlbnRJdGVtLFxuICBJZGVIYXNrZWxsUmVwbEJhc2UsXG4gIElWaWV3U3RhdGUsXG59IGZyb20gJy4vaWRlLWhhc2tlbGwtcmVwbC1iYXNlJ1xuaW1wb3J0ICogYXMgVVBJIGZyb20gJ2F0b20taGFza2VsbC11cGknXG5cbmV4cG9ydCB7IElWaWV3U3RhdGUsIElDb250ZW50SXRlbSB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVR5cGVSZWNvcmQge1xuICB1cmk6IHN0cmluZ1xuICB0eXBlOiBzdHJpbmdcbiAgc3BhbjogUmFuZ2Vcbn1cblxuZXhwb3J0IGNsYXNzIElkZUhhc2tlbGxSZXBsQmcgZXh0ZW5kcyBJZGVIYXNrZWxsUmVwbEJhc2Uge1xuICBwcml2YXRlIHR5cGVzPzogSVR5cGVSZWNvcmRbXVxuICBjb25zdHJ1Y3RvciAodXBpUHJvbWlzZTogUHJvbWlzZTxVUEkuSVVQSUluc3RhbmNlPiwgc3RhdGU6IElWaWV3U3RhdGUpIHtcbiAgICBzdXBlcih1cGlQcm9taXNlLCBzdGF0ZSlcbiAgfVxuXG4gIHB1YmxpYyBzaG93VHlwZUF0ICh1cmk6IHN0cmluZywgaW5yYW5nZTogUmFuZ2UpIHtcbiAgICBpZiAoIXRoaXMudHlwZXMpIHsgcmV0dXJuIHVuZGVmaW5lZCB9XG4gICAgY29uc3QgdHlwZVJlYyA9IHRoaXMudHlwZXMuZmluZCgodHIpID0+IHRyICYmIHRyLnVyaSA9PT0gdXJpICYmIHRyLnNwYW4uY29udGFpbnNSYW5nZShpbnJhbmdlKSlcbiAgICBpZiAoIXR5cGVSZWMpIHsgcmV0dXJuIHVuZGVmaW5lZCB9XG4gICAgY29uc3QgeyBzcGFuOiByYW5nZSwgdHlwZTogdGV4dCB9ID0gdHlwZVJlY1xuICAgIGNvbnN0IGhpZ2hsaWdodGVyID0gJ2hpbnQudHlwZS5oYXNrZWxsJ1xuICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0OiB7IHRleHQsIGhpZ2hsaWdodGVyIH0gfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3kgKCkge1xuICAgIHJldHVybiBzdXBlci5kZXN0cm95KClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB1cGRhdGUgKCkge1xuICAgIC8vIG5vb3BcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBvbkxvYWQgKCkge1xuICAgIGF3YWl0IHRoaXMuZ2V0QWxsVHlwZXMoKVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIG9uSW5pdGlhbExvYWQgKCkge1xuICAgIGlmICghdGhpcy5naGNpKSB7IHRocm93IG5ldyBFcnJvcignTm8gR0hDSSBpbnN0YW5jZSEnKSB9XG4gICAgYXdhaXQgdGhpcy5naGNpLndyaXRlTGluZXMoWyc6c2V0ICtjJ10pXG4gICAgYXdhaXQgdGhpcy5naGNpUmVsb2FkKClcbiAgICByZXR1cm4gc3VwZXIub25Jbml0aWFsTG9hZCgpXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWxsVHlwZXMgKCk6IFByb21pc2U8SVR5cGVSZWNvcmRbXT4ge1xuICAgIGlmICghdGhpcy5naGNpKSB7IHRocm93IG5ldyBFcnJvcignTm8gR0hDSSBpbnN0YW5jZSEnKSB9XG4gICAgY29uc3QgeyBzdGRvdXQgfSA9IGF3YWl0IHRoaXMuZ2hjaS53cml0ZUxpbmVzKFsnOmFsbC10eXBlcyddKVxuICAgIHRoaXMudHlwZXMgPSBbXVxuICAgIGZvciAoY29uc3QgbGluZSBvZiBzdGRvdXQpIHtcbiAgICAgIGNvbnN0IHJ4ID0gL14oLiopOlxcKChcXGQrKSwoXFxkKylcXCktXFwoKFxcZCspLChcXGQrKVxcKTpcXHMqKC4qKSQvXG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocngpXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBtID0gbWF0Y2guc2xpY2UoMSlcbiAgICAgIGNvbnN0IHVyaSA9IG1bMF1cbiAgICAgIGNvbnN0IHR5cGUgPSBtWzVdXG4gICAgICBjb25zdCBbcm93c3RhcnQsIGNvbHN0YXJ0LCByb3dlbmQsIGNvbGVuZF0gPSBtLnNsaWNlKDEpLm1hcCgoaSkgPT4gcGFyc2VJbnQoaSwgMTApIC0gMSlcbiAgICAgIGNvbnN0IHNwYW4gPSBSYW5nZS5mcm9tT2JqZWN0KFtbcm93c3RhcnQsIGNvbHN0YXJ0XSwgW3Jvd2VuZCwgY29sZW5kXV0pXG4gICAgICB0aGlzLnR5cGVzLnB1c2goeyB1cmksIHR5cGUsIHNwYW4gfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHlwZXNcbiAgfVxufVxuIl19