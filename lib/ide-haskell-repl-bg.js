"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const ide_haskell_repl_base_1 = require("./ide-haskell-repl-base");
const path = require("path");
class IdeHaskellReplBg extends ide_haskell_repl_base_1.IdeHaskellReplBase {
    constructor(consumer, state) {
        super(Promise.resolve(consumer), state, `bg:${state.uri}`);
        this.types = [];
        this.gotTypes = this.readyPromise;
    }
    async showTypeAt(uri, inrange) {
        await this.gotTypes;
        if (this.types.length === 0) {
            await this.ghciReload();
        }
        const typeRec = this.types.find((tr) => tr && tr.uri === uri && tr.span.containsRange(inrange));
        if (!typeRec) {
            return undefined;
        }
        const { span: range, type: text } = typeRec;
        const highlighter = 'hint.type.haskell';
        return { range, text: { text, highlighter } };
    }
    async destroy() {
        this.types = [];
        return super.destroy();
    }
    async update() {
    }
    async onInitialLoad() {
        await super.onInitialLoad();
    }
    async onLoad() {
        await super.onLoad();
        await (this.gotTypes = this.getAllTypes());
    }
    async getAllTypes() {
        if (!this.ghci) {
            throw new Error('No GHCI instance!');
        }
        const { stdout } = await this.ghci.writeLines([':all-types']);
        const cwd = this.cwd
            ? this.cwd
            : await ide_haskell_repl_base_1.IdeHaskellReplBase.getRootDir(this.uri);
        this.types = [];
        for (const line of stdout) {
            const rx = /^(.*):\((\d+),(\d+)\)-\((\d+),(\d+)\):\s*(.*)$/;
            const match = line.match(rx);
            if (!match) {
                continue;
            }
            const m = match.slice(1);
            let uri = m[0];
            if (!path.isAbsolute(uri))
                uri = cwd.getFile(uri).getPath();
            const type = m[5];
            const [rowstart, colstart, rowend, colend] = m
                .slice(1)
                .map((i) => parseInt(i, 10) - 1);
            const span = atom_1.Range.fromObject([[rowstart, colstart], [rowend, colend]]);
            this.types.push({ uri, type, span });
        }
    }
}
exports.IdeHaskellReplBg = IdeHaskellReplBg;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlLWhhc2tlbGwtcmVwbC1iZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9pZGUtaGFza2VsbC1yZXBsLWJnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQTRCO0FBQzVCLG1FQUlnQztBQUNoQyw2QkFBNEI7QUFXNUIsTUFBYSxnQkFBaUIsU0FBUSwwQ0FBa0I7SUFHdEQsWUFBWSxRQUFxQixFQUFFLEtBQWlCO1FBQ2xELEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFBO1FBSHBELFVBQUssR0FBa0IsRUFBRSxDQUFBO1FBSS9CLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQTtJQUNuQyxDQUFDO0lBRU0sS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFXLEVBQUUsT0FBYztRQUNqRCxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUE7UUFDbkIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUE7U0FDeEI7UUFDRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDN0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FDL0QsQ0FBQTtRQUNELElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixPQUFPLFNBQVMsQ0FBQTtTQUNqQjtRQUNELE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUE7UUFDM0MsTUFBTSxXQUFXLEdBQUcsbUJBQW1CLENBQUE7UUFDdkMsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQTtJQUMvQyxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUE7UUFDZixPQUFPLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUN4QixDQUFDO0lBRU0sS0FBSyxDQUFDLE1BQU07SUFFbkIsQ0FBQztJQUVTLEtBQUssQ0FBQyxhQUFhO1FBQzNCLE1BQU0sS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFBO0lBQzdCLENBQUM7SUFFUyxLQUFLLENBQUMsTUFBTTtRQUNwQixNQUFNLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQTtRQUNwQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQTtJQUM1QyxDQUFDO0lBRVMsS0FBSyxDQUFDLFdBQVc7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDZCxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7U0FDckM7UUFDRCxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7UUFDN0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUc7WUFDbEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHO1lBQ1YsQ0FBQyxDQUFDLE1BQU0sMENBQWtCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUVqRCxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQTtRQUNmLEtBQUssTUFBTSxJQUFJLElBQUksTUFBTSxFQUFFO1lBQ3pCLE1BQU0sRUFBRSxHQUFHLGdEQUFnRCxDQUFBO1lBQzNELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7WUFDNUIsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDVixTQUFRO2FBQ1Q7WUFDRCxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ3hCLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQztnQkFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtZQUMzRCxNQUFNLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDakIsTUFBTSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUM7aUJBQzNDLEtBQUssQ0FBQyxDQUFDLENBQUM7aUJBQ1IsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO1lBQ2xDLE1BQU0sSUFBSSxHQUFHLFlBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDdkUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7U0FDckM7SUFDSCxDQUFDO0NBQ0Y7QUFyRUQsNENBcUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICdhdG9tJ1xuaW1wb3J0IHtcbiAgSUNvbnRlbnRJdGVtLFxuICBJZGVIYXNrZWxsUmVwbEJhc2UsXG4gIElWaWV3U3RhdGUsXG59IGZyb20gJy4vaWRlLWhhc2tlbGwtcmVwbC1iYXNlJ1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IHsgVVBJQ29uc3VtZXIgfSBmcm9tICcuL3VwaUNvbnN1bWVyJ1xuXG5leHBvcnQgeyBJVmlld1N0YXRlLCBJQ29udGVudEl0ZW0gfVxuXG5leHBvcnQgaW50ZXJmYWNlIElUeXBlUmVjb3JkIHtcbiAgdXJpOiBzdHJpbmdcbiAgdHlwZTogc3RyaW5nXG4gIHNwYW46IFJhbmdlXG59XG5cbmV4cG9ydCBjbGFzcyBJZGVIYXNrZWxsUmVwbEJnIGV4dGVuZHMgSWRlSGFza2VsbFJlcGxCYXNlIHtcbiAgcHJpdmF0ZSB0eXBlczogSVR5cGVSZWNvcmRbXSA9IFtdXG4gIHByaXZhdGUgZ290VHlwZXM6IFByb21pc2U8dm9pZD5cbiAgY29uc3RydWN0b3IoY29uc3VtZXI6IFVQSUNvbnN1bWVyLCBzdGF0ZTogSVZpZXdTdGF0ZSkge1xuICAgIHN1cGVyKFByb21pc2UucmVzb2x2ZShjb25zdW1lciksIHN0YXRlLCBgYmc6JHtzdGF0ZS51cml9YClcbiAgICB0aGlzLmdvdFR5cGVzID0gdGhpcy5yZWFkeVByb21pc2VcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzaG93VHlwZUF0KHVyaTogc3RyaW5nLCBpbnJhbmdlOiBSYW5nZSkge1xuICAgIGF3YWl0IHRoaXMuZ290VHlwZXNcbiAgICBpZiAodGhpcy50eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuZ2hjaVJlbG9hZCgpXG4gICAgfVxuICAgIGNvbnN0IHR5cGVSZWMgPSB0aGlzLnR5cGVzLmZpbmQoXG4gICAgICAodHIpID0+IHRyICYmIHRyLnVyaSA9PT0gdXJpICYmIHRyLnNwYW4uY29udGFpbnNSYW5nZShpbnJhbmdlKSxcbiAgICApXG4gICAgaWYgKCF0eXBlUmVjKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IHsgc3BhbjogcmFuZ2UsIHR5cGU6IHRleHQgfSA9IHR5cGVSZWNcbiAgICBjb25zdCBoaWdobGlnaHRlciA9ICdoaW50LnR5cGUuaGFza2VsbCdcbiAgICByZXR1cm4geyByYW5nZSwgdGV4dDogeyB0ZXh0LCBoaWdobGlnaHRlciB9IH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMudHlwZXMgPSBbXVxuICAgIHJldHVybiBzdXBlci5kZXN0cm95KClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB1cGRhdGUoKSB7XG4gICAgLy8gbm9vcFxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIG9uSW5pdGlhbExvYWQoKSB7XG4gICAgYXdhaXQgc3VwZXIub25Jbml0aWFsTG9hZCgpXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgb25Mb2FkKCkge1xuICAgIGF3YWl0IHN1cGVyLm9uTG9hZCgpXG4gICAgYXdhaXQgKHRoaXMuZ290VHlwZXMgPSB0aGlzLmdldEFsbFR5cGVzKCkpXG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWxsVHlwZXMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmdoY2kpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gR0hDSSBpbnN0YW5jZSEnKVxuICAgIH1cbiAgICBjb25zdCB7IHN0ZG91dCB9ID0gYXdhaXQgdGhpcy5naGNpLndyaXRlTGluZXMoWyc6YWxsLXR5cGVzJ10pXG4gICAgY29uc3QgY3dkID0gdGhpcy5jd2RcbiAgICAgID8gdGhpcy5jd2RcbiAgICAgIDogYXdhaXQgSWRlSGFza2VsbFJlcGxCYXNlLmdldFJvb3REaXIodGhpcy51cmkpXG4gICAgLy8gTk9URTogZG8gbm90IGF3YWl0IGJldHdlZW4gc2V0dGluZyB0eXBlcyB0byBbXSBhbmQgcmV0dXJuaW5nIHRvIGF2b2lkIGR1cGxpY2F0ZSBjYWxsc1xuICAgIHRoaXMudHlwZXMgPSBbXVxuICAgIGZvciAoY29uc3QgbGluZSBvZiBzdGRvdXQpIHtcbiAgICAgIGNvbnN0IHJ4ID0gL14oLiopOlxcKChcXGQrKSwoXFxkKylcXCktXFwoKFxcZCspLChcXGQrKVxcKTpcXHMqKC4qKSQvXG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2gocngpXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBtID0gbWF0Y2guc2xpY2UoMSlcbiAgICAgIGxldCB1cmkgPSBtWzBdXG4gICAgICBpZiAoIXBhdGguaXNBYnNvbHV0ZSh1cmkpKSB1cmkgPSBjd2QuZ2V0RmlsZSh1cmkpLmdldFBhdGgoKVxuICAgICAgY29uc3QgdHlwZSA9IG1bNV1cbiAgICAgIGNvbnN0IFtyb3dzdGFydCwgY29sc3RhcnQsIHJvd2VuZCwgY29sZW5kXSA9IG1cbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5tYXAoKGkpID0+IHBhcnNlSW50KGksIDEwKSAtIDEpXG4gICAgICBjb25zdCBzcGFuID0gUmFuZ2UuZnJvbU9iamVjdChbW3Jvd3N0YXJ0LCBjb2xzdGFydF0sIFtyb3dlbmQsIGNvbGVuZF1dKVxuICAgICAgdGhpcy50eXBlcy5wdXNoKHsgdXJpLCB0eXBlLCBzcGFuIH0pXG4gICAgfVxuICB9XG59XG4iXX0=